#!/usr/bin/env perl
use strict;
use warnings;
use Term::ANSIColor;
use File::Spec::Functions qw(catfile);
use File::Path            qw(remove_tree);
use File::HomeDir;
use POSIX ":sys_wait_h";
use Getopt::Long;
use Cwd qw(getcwd);

my $VERBOSE    = 0;
my $START_TIME = time();
my $CWD        = getcwd();
my $HOME       = File::HomeDir->my_home;
my $OS         = $^O;
my $IS_WINDOWS = $OS eq 'MSWin32';
my $NULL       = $IS_WINDOWS ? 'NUL' : '/dev/null';

GetOptions( "verbose" => \$VERBOSE );

sub timestamp { sprintf "[%02d:%02d:%02d]", ( localtime() )[ 2, 1, 0 ] }

sub log_line {
    my ( $color, $tag, $msg ) = @_;
    print color($color), sprintf( "%s %-10s", timestamp(), "[$tag]" ),
      color('white'), " $msg\n", color('reset');
}

sub info  { log_line( 'green',  'INFO',  "@_" ); }
sub warn  { log_line( 'yellow', 'WARN',  "@_" ); }
sub error { log_line( 'red',    'ERROR', "@_" ); }
sub diex  { error(@_); exit 1; }

sub section {
    print color('cyan'), "\n=== ", shift, " ===\n", color('reset');
}

sub run {
    my ( $cmd, $dir ) = @_;
    $dir ||= '.';
    my $verbose_cmd = $VERBOSE ? "" : " > $NULL 2>&1";

    info("($dir) $cmd") if $VERBOSE;

    my $pid = fork();
    if ( $pid == 0 ) {
        chdir $dir or diex "Failed to cd into $dir: $!";
        exec "sh", "-c", $cmd . $verbose_cmd or diex "Exec failed: $!";
    }

    waitpid( $pid, 0 );
    my $exit = $? >> 8;

    if ( $exit != 0 ) {
        if ( !$VERBOSE ) {
            error("Command failed, showing output: $cmd");
            system( "sh", "-c", $cmd );
        }
        diex("Command failed: $cmd (exit code $exit)");
    }
    return $exit;
}

sub boot {
    section "Bootstrapping Project";
    my @dirs = ( '.', 'src' );
    my $cmd  = 'autoreconf -i';

    if ($IS_WINDOWS) {
        info "Detected Windows environment";
        my $ac = $ENV{ACLOCAL_PATH} // '';
        $ac =~ s/;/:/g;
        $ac =~ s|\\|/|g;
        $ac =~ s|([A-Za-z]):/|/$1/|g;
        $cmd = "ACLOCAL_PATH=$ac autoreconf -i";
    }
    elsif ( $OS eq 'darwin' ) {
        info "Detected macOS, performing additional setup...";
        run("aclocal");
        run("autoheader");

        for my $d (@dirs) {
            run( "automake --add-missing", $d )
              if -f catfile( $d, "configure.ac" );
        }
    }

    for my $d (@dirs) {
        next unless -f catfile( $d, "configure.ac" );
        info "Running autoreconf in $d...";
        run( $cmd, $d );
    }

    info "Autoreconf completed successfully.";
}

sub clean {
    section "Cleaning Project";

    run("make clean") if -e "Makefile";

    my @targets = qw(
      autom4te.cache config.log config.status Makefile Makefile.in
      source/.deps source/Makefile source/Makefile.in
      source/include/config.h.in source/include/config.h source/include/stamp-h1
      tests/.deps tests/Makefile tests/Makefile.in
      configure aclocal.m4
      config/compile config/depcomp config/install-sh config/missing config/test-driver
    );

    for my $t (@targets) {
        next unless -e $t;
        -d $t ? remove_tree($t) : unlink $t;
        info("Removed $t") if $VERBOSE;
    }

    info "Cleanup complete.";
}

sub build {
    section "Building Project";
    run("./configure");
    run("make");
    info "Build complete.";
}

sub check {
    section "Running Tests";
    run("make check");
    info "All tests passed.";
}

sub rebuild { section "Full Rebuild"; clean(); build(); }

sub install {
    section "Installing Thale";
    my $prefix  = "$HOME/.thale";
    my $bin_dir = "$prefix/bin";

    run("make install prefix=$prefix");
    info "Installed Thale to $bin_dir";
    add_to_path($bin_dir);
}

sub uninstall {
    section "Uninstalling Thale";
    my $prefix  = "$HOME/.thale";
    my $bin_dir = "$prefix/bin";

    run("make uninstall prefix=$prefix");
    info "Uninstalled Thale";

    remove_from_path($bin_dir);
    remove_tree($prefix) if -d $prefix;
    info "Removed directory $prefix";
}

sub remove_from_path {
    my ($bin_dir) = @_;
    info "Removing $bin_dir from PATH...";

    if ($IS_WINDOWS) {
        my $ps_cmd = qq{
            \$old = [Environment]::GetEnvironmentVariable('Path','User');
            if (\$old) {
                \$new = (\$old -split ';') | Where-Object { \$_ -ne '$bin_dir' -and \$_ -ne '' };
                [Environment]::SetEnvironmentVariable('Path', (\$new -join ';'),'User');
            }
        };
        system( "powershell", "-NoProfile", "-Command", $ps_cmd ) == 0
          ? info "Removed $bin_dir from user PATH"
          : &warn("Could not update PATH automatically on Windows.");
    }
    else {
        my @rc_files =
          grep { -f $_ } ( "$HOME/.bashrc", "$HOME/.zshrc", "$HOME/.profile" );
        my $escaped = quotemeta($bin_dir);
        foreach my $rc (@rc_files) {
            open my $in, '<', $rc or next;
            my @lines = <$in>;
            close $in;

            my @filtered = grep { $_ !~ /$escaped/ } @lines;
            next if @filtered == @lines;

            open my $out, '>', $rc or next;
            print $out @filtered;
            close $out;
            info "Removed $bin_dir from PATH in $rc";
        }
        info "PATH cleanup complete.";
    }
}

sub add_to_path {
    my ($bin_path) = @_;

    if ($IS_WINDOWS) {
        system( "powershell", "-NoProfile", "-Command",
"[Environment]::SetEnvironmentVariable('Path', \$env:Path + ';$bin_path', 'User')"
        );
        info "Added $bin_path to PATH";
    }
    else {
        my $shell_rc =
            $ENV{SHELL} =~ /zsh/  ? "$HOME/.zshrc"
          : $ENV{SHELL} =~ /fish/ ? "$HOME/.config/fish/config.fish"
          :                         "$HOME/.bashrc";

        open my $fh, '>>', $shell_rc or &warn("Cannot open $shell_rc: $!");
        print $fh
          "\n# Added by Thale installer\nexport PATH=\"$bin_path:\$PATH\"\n";
        close $fh;
        info "Added $bin_path to PATH in $shell_rc";
    }
}

my %commands = (
    boot      => \&boot,
    clean     => \&clean,
    build     => \&build,
    check     => \&check,
    rebuild   => \&rebuild,
    install   => \&install,
    uninstall => \&uninstall,
);

my $cmd = shift // 'boot';
exists $commands{$cmd}
  ? $commands{$cmd}->()
  : diex
"Unknown command: '$cmd'\nUsage: $0 [boot|clean|build|check|rebuild|install|uninstall] [--verbose]";

info sprintf( "Completed in %ds", time() - $START_TIME );
